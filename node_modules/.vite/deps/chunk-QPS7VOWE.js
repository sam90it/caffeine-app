import {
  AgentError,
  Certificate,
  HttpAgent,
  Principal,
  ReplicaRejectCode,
  RequestStatusResponseStatus,
  bufFromBufLike2 as bufFromBufLike,
  canisterStatus_exports,
  cbor_exports,
  getDefaultAgent,
  idl_exports,
  lookupResultToBuffer,
  request,
  toHex
} from "./chunk-WH4AAL63.js";
import {
  require_buffer
} from "./chunk-UP7SMLPE.js";
import {
  __export,
  __toESM
} from "./chunk-4MBMRILA.js";

// node_modules/@dfinity/agent/lib/esm/actor.js
var import_buffer3 = __toESM(require_buffer());

// node_modules/@dfinity/agent/lib/esm/polling/index.js
var polling_exports = {};
__export(polling_exports, {
  defaultStrategy: () => defaultStrategy,
  pollForResponse: () => pollForResponse,
  strategy: () => strategy_exports
});

// node_modules/@dfinity/agent/lib/esm/polling/strategy.js
var strategy_exports = {};
__export(strategy_exports, {
  backoff: () => backoff,
  chain: () => chain,
  conditionalDelay: () => conditionalDelay,
  defaultStrategy: () => defaultStrategy,
  maxAttempts: () => maxAttempts,
  once: () => once,
  throttle: () => throttle,
  timeout: () => timeout
});
var FIVE_MINUTES_IN_MSEC = 5 * 60 * 1e3;
function defaultStrategy() {
  return chain(conditionalDelay(once(), 1e3), backoff(1e3, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
}
function once() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function maxAttempts(count) {
  let attempts = count;
  return async (canisterId, requestId, status) => {
    if (--attempts <= 0) {
      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`);
    }
  };
}
function throttle(throttleInMsec) {
  return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
}
function timeout(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`);
    }
  };
}
function backoff(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}

// node_modules/@dfinity/agent/lib/esm/polling/index.js
async function pollForResponse(agent, canisterId, requestId, strategy = defaultStrategy(), request2, blsVerify) {
  var _a;
  const path = [new TextEncoder().encode("request_status"), requestId];
  const currentRequest = request2 !== null && request2 !== void 0 ? request2 : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] }));
  const state = await agent.readState(canisterId, { paths: [path] }, void 0, currentRequest);
  if (agent.rootKey == null)
    throw new Error("Agent root key not initialized before polling");
  const cert = await Certificate.create({
    certificate: state.certificate,
    rootKey: agent.rootKey,
    canisterId,
    blsVerify
  });
  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode("status")]));
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus.Unknown;
  } else {
    status = new TextDecoder().decode(maybeBuf);
  }
  switch (status) {
    case RequestStatusResponseStatus.Replied: {
      return {
        reply: lookupResultToBuffer(cert.lookup([...path, "reply"])),
        certificate: cert
      };
    }
    case RequestStatusResponseStatus.Received:
    case RequestStatusResponseStatus.Unknown:
    case RequestStatusResponseStatus.Processing:
      await strategy(canisterId, requestId, status);
      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);
    case RequestStatusResponseStatus.Rejected: {
      const rejectCode = new Uint8Array(lookupResultToBuffer(cert.lookup([...path, "reject_code"])))[0];
      const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(cert.lookup([...path, "reject_message"])));
      throw new Error(`Call was rejected:
  Request ID: ${toHex(requestId)}
  Reject code: ${rejectCode}
  Reject text: ${rejectMessage}
`);
    }
    case RequestStatusResponseStatus.Done:
      throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${toHex(requestId)}
`);
  }
  throw new Error("unreachable");
}

// node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js
var management_idl_default = ({ IDL }) => {
  const bitcoin_network = IDL.Variant({
    mainnet: IDL.Null,
    testnet: IDL.Null
  });
  const bitcoin_address = IDL.Text;
  const bitcoin_get_balance_args = IDL.Record({
    network: bitcoin_network,
    address: bitcoin_address,
    min_confirmations: IDL.Opt(IDL.Nat32)
  });
  const satoshi = IDL.Nat64;
  const bitcoin_get_balance_result = satoshi;
  const bitcoin_block_height = IDL.Nat32;
  const bitcoin_get_block_headers_args = IDL.Record({
    start_height: bitcoin_block_height,
    end_height: IDL.Opt(bitcoin_block_height),
    network: bitcoin_network
  });
  const bitcoin_block_header = IDL.Vec(IDL.Nat8);
  const bitcoin_get_block_headers_result = IDL.Record({
    tip_height: bitcoin_block_height,
    block_headers: IDL.Vec(bitcoin_block_header)
  });
  const bitcoin_get_current_fee_percentiles_args = IDL.Record({
    network: bitcoin_network
  });
  const millisatoshi_per_byte = IDL.Nat64;
  const bitcoin_get_current_fee_percentiles_result = IDL.Vec(millisatoshi_per_byte);
  const bitcoin_get_utxos_args = IDL.Record({
    network: bitcoin_network,
    filter: IDL.Opt(IDL.Variant({
      page: IDL.Vec(IDL.Nat8),
      min_confirmations: IDL.Nat32
    })),
    address: bitcoin_address
  });
  const bitcoin_block_hash = IDL.Vec(IDL.Nat8);
  const outpoint = IDL.Record({
    txid: IDL.Vec(IDL.Nat8),
    vout: IDL.Nat32
  });
  const utxo = IDL.Record({
    height: IDL.Nat32,
    value: satoshi,
    outpoint
  });
  const bitcoin_get_utxos_result = IDL.Record({
    next_page: IDL.Opt(IDL.Vec(IDL.Nat8)),
    tip_height: bitcoin_block_height,
    tip_block_hash: bitcoin_block_hash,
    utxos: IDL.Vec(utxo)
  });
  const bitcoin_send_transaction_args = IDL.Record({
    transaction: IDL.Vec(IDL.Nat8),
    network: bitcoin_network
  });
  const canister_id = IDL.Principal;
  const canister_info_args = IDL.Record({
    canister_id,
    num_requested_changes: IDL.Opt(IDL.Nat64)
  });
  const change_origin = IDL.Variant({
    from_user: IDL.Record({ user_id: IDL.Principal }),
    from_canister: IDL.Record({
      canister_version: IDL.Opt(IDL.Nat64),
      canister_id: IDL.Principal
    })
  });
  const snapshot_id = IDL.Vec(IDL.Nat8);
  const change_details = IDL.Variant({
    creation: IDL.Record({ controllers: IDL.Vec(IDL.Principal) }),
    code_deployment: IDL.Record({
      mode: IDL.Variant({
        reinstall: IDL.Null,
        upgrade: IDL.Null,
        install: IDL.Null
      }),
      module_hash: IDL.Vec(IDL.Nat8)
    }),
    load_snapshot: IDL.Record({
      canister_version: IDL.Nat64,
      taken_at_timestamp: IDL.Nat64,
      snapshot_id
    }),
    controllers_change: IDL.Record({
      controllers: IDL.Vec(IDL.Principal)
    }),
    code_uninstall: IDL.Null
  });
  const change = IDL.Record({
    timestamp_nanos: IDL.Nat64,
    canister_version: IDL.Nat64,
    origin: change_origin,
    details: change_details
  });
  const canister_info_result = IDL.Record({
    controllers: IDL.Vec(IDL.Principal),
    module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
    recent_changes: IDL.Vec(change),
    total_num_changes: IDL.Nat64
  });
  const canister_status_args = IDL.Record({ canister_id });
  const log_visibility = IDL.Variant({
    controllers: IDL.Null,
    public: IDL.Null,
    allowed_viewers: IDL.Vec(IDL.Principal)
  });
  const definite_canister_settings = IDL.Record({
    freezing_threshold: IDL.Nat,
    controllers: IDL.Vec(IDL.Principal),
    reserved_cycles_limit: IDL.Nat,
    log_visibility,
    wasm_memory_limit: IDL.Nat,
    memory_allocation: IDL.Nat,
    compute_allocation: IDL.Nat
  });
  const canister_status_result = IDL.Record({
    status: IDL.Variant({
      stopped: IDL.Null,
      stopping: IDL.Null,
      running: IDL.Null
    }),
    memory_size: IDL.Nat,
    cycles: IDL.Nat,
    settings: definite_canister_settings,
    query_stats: IDL.Record({
      response_payload_bytes_total: IDL.Nat,
      num_instructions_total: IDL.Nat,
      num_calls_total: IDL.Nat,
      request_payload_bytes_total: IDL.Nat
    }),
    idle_cycles_burned_per_day: IDL.Nat,
    module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
    reserved_cycles: IDL.Nat
  });
  const clear_chunk_store_args = IDL.Record({ canister_id });
  const canister_settings = IDL.Record({
    freezing_threshold: IDL.Opt(IDL.Nat),
    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
    reserved_cycles_limit: IDL.Opt(IDL.Nat),
    log_visibility: IDL.Opt(log_visibility),
    wasm_memory_limit: IDL.Opt(IDL.Nat),
    memory_allocation: IDL.Opt(IDL.Nat),
    compute_allocation: IDL.Opt(IDL.Nat)
  });
  const create_canister_args = IDL.Record({
    settings: IDL.Opt(canister_settings),
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const create_canister_result = IDL.Record({ canister_id });
  const delete_canister_args = IDL.Record({ canister_id });
  const delete_canister_snapshot_args = IDL.Record({
    canister_id,
    snapshot_id
  });
  const deposit_cycles_args = IDL.Record({ canister_id });
  const ecdsa_curve = IDL.Variant({ secp256k1: IDL.Null });
  const ecdsa_public_key_args = IDL.Record({
    key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),
    canister_id: IDL.Opt(canister_id),
    derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
  });
  const ecdsa_public_key_result = IDL.Record({
    public_key: IDL.Vec(IDL.Nat8),
    chain_code: IDL.Vec(IDL.Nat8)
  });
  const fetch_canister_logs_args = IDL.Record({ canister_id });
  const canister_log_record = IDL.Record({
    idx: IDL.Nat64,
    timestamp_nanos: IDL.Nat64,
    content: IDL.Vec(IDL.Nat8)
  });
  const fetch_canister_logs_result = IDL.Record({
    canister_log_records: IDL.Vec(canister_log_record)
  });
  const http_header = IDL.Record({ value: IDL.Text, name: IDL.Text });
  const http_request_result = IDL.Record({
    status: IDL.Nat,
    body: IDL.Vec(IDL.Nat8),
    headers: IDL.Vec(http_header)
  });
  const http_request_args = IDL.Record({
    url: IDL.Text,
    method: IDL.Variant({
      get: IDL.Null,
      head: IDL.Null,
      post: IDL.Null
    }),
    max_response_bytes: IDL.Opt(IDL.Nat64),
    body: IDL.Opt(IDL.Vec(IDL.Nat8)),
    transform: IDL.Opt(IDL.Record({
      function: IDL.Func([
        IDL.Record({
          context: IDL.Vec(IDL.Nat8),
          response: http_request_result
        })
      ], [http_request_result], ["query"]),
      context: IDL.Vec(IDL.Nat8)
    })),
    headers: IDL.Vec(http_header)
  });
  const canister_install_mode = IDL.Variant({
    reinstall: IDL.Null,
    upgrade: IDL.Opt(IDL.Record({
      wasm_memory_persistence: IDL.Opt(IDL.Variant({ keep: IDL.Null, replace: IDL.Null })),
      skip_pre_upgrade: IDL.Opt(IDL.Bool)
    })),
    install: IDL.Null
  });
  const chunk_hash = IDL.Record({ hash: IDL.Vec(IDL.Nat8) });
  const install_chunked_code_args = IDL.Record({
    arg: IDL.Vec(IDL.Nat8),
    wasm_module_hash: IDL.Vec(IDL.Nat8),
    mode: canister_install_mode,
    chunk_hashes_list: IDL.Vec(chunk_hash),
    target_canister: canister_id,
    store_canister: IDL.Opt(canister_id),
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const wasm_module = IDL.Vec(IDL.Nat8);
  const install_code_args = IDL.Record({
    arg: IDL.Vec(IDL.Nat8),
    wasm_module,
    mode: canister_install_mode,
    canister_id,
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const list_canister_snapshots_args = IDL.Record({
    canister_id
  });
  const snapshot = IDL.Record({
    id: snapshot_id,
    total_size: IDL.Nat64,
    taken_at_timestamp: IDL.Nat64
  });
  const list_canister_snapshots_result = IDL.Vec(snapshot);
  const load_canister_snapshot_args = IDL.Record({
    canister_id,
    sender_canister_version: IDL.Opt(IDL.Nat64),
    snapshot_id
  });
  const node_metrics_history_args = IDL.Record({
    start_at_timestamp_nanos: IDL.Nat64,
    subnet_id: IDL.Principal
  });
  const node_metrics = IDL.Record({
    num_block_failures_total: IDL.Nat64,
    node_id: IDL.Principal,
    num_blocks_proposed_total: IDL.Nat64
  });
  const node_metrics_history_result = IDL.Vec(IDL.Record({
    timestamp_nanos: IDL.Nat64,
    node_metrics: IDL.Vec(node_metrics)
  }));
  const provisional_create_canister_with_cycles_args = IDL.Record({
    settings: IDL.Opt(canister_settings),
    specified_id: IDL.Opt(canister_id),
    amount: IDL.Opt(IDL.Nat),
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const provisional_create_canister_with_cycles_result = IDL.Record({
    canister_id
  });
  const provisional_top_up_canister_args = IDL.Record({
    canister_id,
    amount: IDL.Nat
  });
  const raw_rand_result = IDL.Vec(IDL.Nat8);
  const schnorr_algorithm = IDL.Variant({
    ed25519: IDL.Null,
    bip340secp256k1: IDL.Null
  });
  const schnorr_public_key_args = IDL.Record({
    key_id: IDL.Record({
      algorithm: schnorr_algorithm,
      name: IDL.Text
    }),
    canister_id: IDL.Opt(canister_id),
    derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
  });
  const schnorr_public_key_result = IDL.Record({
    public_key: IDL.Vec(IDL.Nat8),
    chain_code: IDL.Vec(IDL.Nat8)
  });
  const sign_with_ecdsa_args = IDL.Record({
    key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),
    derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
    message_hash: IDL.Vec(IDL.Nat8)
  });
  const sign_with_ecdsa_result = IDL.Record({
    signature: IDL.Vec(IDL.Nat8)
  });
  const schnorr_aux = IDL.Variant({
    bip341: IDL.Record({ merkle_root_hash: IDL.Vec(IDL.Nat8) })
  });
  const sign_with_schnorr_args = IDL.Record({
    aux: IDL.Opt(schnorr_aux),
    key_id: IDL.Record({
      algorithm: schnorr_algorithm,
      name: IDL.Text
    }),
    derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
    message: IDL.Vec(IDL.Nat8)
  });
  const sign_with_schnorr_result = IDL.Record({
    signature: IDL.Vec(IDL.Nat8)
  });
  const start_canister_args = IDL.Record({ canister_id });
  const stop_canister_args = IDL.Record({ canister_id });
  const stored_chunks_args = IDL.Record({ canister_id });
  const stored_chunks_result = IDL.Vec(chunk_hash);
  const subnet_info_args = IDL.Record({ subnet_id: IDL.Principal });
  const subnet_info_result = IDL.Record({ replica_version: IDL.Text });
  const take_canister_snapshot_args = IDL.Record({
    replace_snapshot: IDL.Opt(snapshot_id),
    canister_id
  });
  const take_canister_snapshot_result = snapshot;
  const uninstall_code_args = IDL.Record({
    canister_id,
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const update_settings_args = IDL.Record({
    canister_id: IDL.Principal,
    settings: canister_settings,
    sender_canister_version: IDL.Opt(IDL.Nat64)
  });
  const upload_chunk_args = IDL.Record({
    chunk: IDL.Vec(IDL.Nat8),
    canister_id: IDL.Principal
  });
  const upload_chunk_result = chunk_hash;
  return IDL.Service({
    bitcoin_get_balance: IDL.Func([bitcoin_get_balance_args], [bitcoin_get_balance_result], []),
    bitcoin_get_block_headers: IDL.Func([bitcoin_get_block_headers_args], [bitcoin_get_block_headers_result], []),
    bitcoin_get_current_fee_percentiles: IDL.Func([bitcoin_get_current_fee_percentiles_args], [bitcoin_get_current_fee_percentiles_result], []),
    bitcoin_get_utxos: IDL.Func([bitcoin_get_utxos_args], [bitcoin_get_utxos_result], []),
    bitcoin_send_transaction: IDL.Func([bitcoin_send_transaction_args], [], []),
    canister_info: IDL.Func([canister_info_args], [canister_info_result], []),
    canister_status: IDL.Func([canister_status_args], [canister_status_result], []),
    clear_chunk_store: IDL.Func([clear_chunk_store_args], [], []),
    create_canister: IDL.Func([create_canister_args], [create_canister_result], []),
    delete_canister: IDL.Func([delete_canister_args], [], []),
    delete_canister_snapshot: IDL.Func([delete_canister_snapshot_args], [], []),
    deposit_cycles: IDL.Func([deposit_cycles_args], [], []),
    ecdsa_public_key: IDL.Func([ecdsa_public_key_args], [ecdsa_public_key_result], []),
    fetch_canister_logs: IDL.Func([fetch_canister_logs_args], [fetch_canister_logs_result], ["query"]),
    http_request: IDL.Func([http_request_args], [http_request_result], []),
    install_chunked_code: IDL.Func([install_chunked_code_args], [], []),
    install_code: IDL.Func([install_code_args], [], []),
    list_canister_snapshots: IDL.Func([list_canister_snapshots_args], [list_canister_snapshots_result], []),
    load_canister_snapshot: IDL.Func([load_canister_snapshot_args], [], []),
    node_metrics_history: IDL.Func([node_metrics_history_args], [node_metrics_history_result], []),
    provisional_create_canister_with_cycles: IDL.Func([provisional_create_canister_with_cycles_args], [provisional_create_canister_with_cycles_result], []),
    provisional_top_up_canister: IDL.Func([provisional_top_up_canister_args], [], []),
    raw_rand: IDL.Func([], [raw_rand_result], []),
    schnorr_public_key: IDL.Func([schnorr_public_key_args], [schnorr_public_key_result], []),
    sign_with_ecdsa: IDL.Func([sign_with_ecdsa_args], [sign_with_ecdsa_result], []),
    sign_with_schnorr: IDL.Func([sign_with_schnorr_args], [sign_with_schnorr_result], []),
    start_canister: IDL.Func([start_canister_args], [], []),
    stop_canister: IDL.Func([stop_canister_args], [], []),
    stored_chunks: IDL.Func([stored_chunks_args], [stored_chunks_result], []),
    subnet_info: IDL.Func([subnet_info_args], [subnet_info_result], []),
    take_canister_snapshot: IDL.Func([take_canister_snapshot_args], [take_canister_snapshot_result], []),
    uninstall_code: IDL.Func([uninstall_code_args], [], []),
    update_settings: IDL.Func([update_settings_args], [], []),
    upload_chunk: IDL.Func([upload_chunk_args], [upload_chunk_result], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/actor.js
var ActorCallError = class extends AgentError {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n) => `  "${n}": ${JSON.stringify(props[n])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
};
var QueryCallRejectedError = class extends ActorCallError {
  constructor(canisterId, methodName, result) {
    var _a;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
};
var UpdateCallRejectedError = class extends ActorCallError {
  constructor(canisterId, methodName, requestId, response, reject_code, reject_message, error_code) {
    super(canisterId, methodName, "update", Object.assign({ "Request ID": toHex(requestId) }, response.body ? Object.assign(Object.assign({}, error_code ? {
      "Error code": error_code
    } : {}), { "Reject code": String(reject_code), "Reject message": reject_message }) : {
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    }));
    this.requestId = requestId;
    this.response = response;
    this.reject_code = reject_code;
    this.reject_message = reject_message;
    this.error_code = error_code;
  }
};
var metadataSymbol = Symbol.for("ic-agent-metadata");
var Actor = class _Actor {
  constructor(metadata) {
    this[metadataSymbol] = Object.freeze(metadata);
  }
  /**
   * Get the Agent class this Actor would call, or undefined if the Actor would use
   * the default agent (global.ic.agent).
   * @param actor The actor to get the agent of.
   */
  static agentOf(actor) {
    return actor[metadataSymbol].config.agent;
  }
  /**
   * Get the interface of an actor, in the form of an instance of a Service.
   * @param actor The actor to get the interface of.
   */
  static interfaceOf(actor) {
    return actor[metadataSymbol].service;
  }
  static canisterIdOf(actor) {
    return Principal.from(actor[metadataSymbol].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === void 0 ? { install: null } : fields.mode;
    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
    const wasmModule = [...new Uint8Array(fields.module)];
    const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister(config).install_code({
      mode,
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId,
      sender_canister_version: []
    });
  }
  static async createCanister(config, settings) {
    function settingsToCanisterSettings(settings2) {
      return [
        {
          controllers: settings2.controllers ? [settings2.controllers] : [],
          compute_allocation: settings2.compute_allocation ? [settings2.compute_allocation] : [],
          freezing_threshold: settings2.freezing_threshold ? [settings2.freezing_threshold] : [],
          memory_allocation: settings2.memory_allocation ? [settings2.memory_allocation] : [],
          reserved_cycles_limit: [],
          log_visibility: [],
          wasm_memory_limit: []
        }
      ];
    }
    const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({
      amount: [],
      settings: settingsToCanisterSettings(settings || {}),
      specified_id: [],
      sender_canister_version: []
    });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory, options) {
    const service = interfaceFactory({ IDL: idl_exports });
    class CanisterActor extends _Actor {
      constructor(config) {
        if (!config.canisterId)
          throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
        const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          if (options === null || options === void 0 ? void 0 : options.httpDetails) {
            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
          }
          if (options === null || options === void 0 ? void 0 : options.certificate) {
            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);
          }
          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    if (!configuration.canisterId) {
      throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
    }
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
  /**
   * Returns an actor with methods that return the http response details along with the result
   * @param interfaceFactory - the interface factory for the actor
   * @param configuration - the configuration for the actor
   * @deprecated - use createActor with actorClassOptions instead
   */
  static createActorWithHttpDetails(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);
  }
  /**
   * Returns an actor with methods that return the http response details along with the result
   * @param interfaceFactory - the interface factory for the actor
   * @param configuration - the configuration for the actor
   * @param actorClassOptions - options for the actor class extended details to return with the result
   */
  static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {
    httpDetails: true,
    certificate: true
  }) {
    return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);
  }
};
function decodeReturnValue(types, msg) {
  const returnValues = idl_exports.decode(types, import_buffer3.Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return void 0;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
}
var DEFAULT_ACTOR_CONFIG = {
  pollingStrategyFactory: strategy_exports.defaultStrategy
};
var ACTOR_METHOD_WITH_HTTP_DETAILS = "http-details";
var ACTOR_METHOD_WITH_CERTIFICATE = "certificate";
function _createActorMethod(actor, methodName, func, blsVerify) {
  let caller;
  if (func.annotations.includes("query") || func.annotations.includes("composite_query")) {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
      const arg = idl_exports.encode(func.argTypes, args);
      const result = await agent.query(cid, {
        methodName,
        arg,
        effectiveCanisterId: options.effectiveCanisterId
      });
      const httpDetails = Object.assign(Object.assign({}, result.httpDetails), { requestDetails: result.requestDetails });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError(cid, methodName, result);
        case "replied":
          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
            httpDetails,
            result: decodeReturnValue(func.retTypes, result.reply.arg)
          } : decodeReturnValue(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
      const cid = Principal.from(canisterId);
      const ecid = effectiveCanisterId !== void 0 ? Principal.from(effectiveCanisterId) : cid;
      const arg = idl_exports.encode(func.argTypes, args);
      const { requestId, response, requestDetails } = await agent.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      let reply;
      let certificate;
      if (response.body && response.body.certificate) {
        if (agent.rootKey == null) {
          throw new Error("Agent is missing root key");
        }
        const cert = response.body.certificate;
        certificate = await Certificate.create({
          certificate: bufFromBufLike(cert),
          rootKey: agent.rootKey,
          canisterId: Principal.from(canisterId),
          blsVerify
        });
        const path = [new TextEncoder().encode("request_status"), requestId];
        const status = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup([...path, "status"])));
        switch (status) {
          case "replied":
            reply = lookupResultToBuffer(certificate.lookup([...path, "reply"]));
            break;
          case "rejected": {
            const rejectCode = new Uint8Array(lookupResultToBuffer(certificate.lookup([...path, "reject_code"])))[0];
            const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup([...path, "reject_message"])));
            const error_code_buf = lookupResultToBuffer(certificate.lookup([...path, "error_code"]));
            const error_code = error_code_buf ? new TextDecoder().decode(error_code_buf) : void 0;
            throw new UpdateCallRejectedError(cid, methodName, requestId, response, rejectCode, rejectMessage, error_code);
          }
        }
      } else if (response.body && "reject_message" in response.body) {
        const { reject_code, reject_message, error_code } = response.body;
        throw new UpdateCallRejectedError(cid, methodName, requestId, response, reject_code, reject_message, error_code);
      }
      if (response.status === 202) {
        const pollStrategy = pollingStrategyFactory();
        const response2 = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);
        certificate = response2.certificate;
        reply = response2.reply;
      }
      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);
      const httpDetails = Object.assign(Object.assign({}, response), { requestDetails });
      if (reply !== void 0) {
        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {
          return {
            httpDetails,
            certificate,
            result: decodeReturnValue(func.retTypes, reply)
          };
        } else if (shouldIncludeCertificate) {
          return {
            certificate,
            result: decodeReturnValue(func.retTypes, reply)
          };
        } else if (shouldIncludeHttpDetails) {
          return {
            httpDetails,
            result: decodeReturnValue(func.retTypes, reply)
          };
        }
        return decodeReturnValue(func.retTypes, reply);
      } else if (func.retTypes.length === 0) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: void 0
        } : void 0;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
}
function getManagementCanister(config) {
  function transform(methodName, args) {
    if (config.effectiveCanisterId) {
      return { effectiveCanisterId: Principal.from(config.effectiveCanisterId) };
    }
    const first = args[0];
    let effectiveCanisterId = Principal.fromHex("");
    if (first && typeof first === "object" && first.target_canister && methodName === "install_chunked_code") {
      effectiveCanisterId = Principal.from(first.target_canister);
    }
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = Principal.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor.createActor(management_idl_default, Object.assign(Object.assign(Object.assign({}, config), { canisterId: Principal.fromHex("") }), {
    callTransform: transform,
    queryTransform: transform
  }));
}
var AdvancedActor = class extends Actor {
  constructor(metadata) {
    super(metadata);
  }
};

// node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js
var asset_idl_default = ({ IDL }) => {
  return IDL.Service({
    retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ["query"]),
    store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/canisters/asset.js
function createAssetCanisterActor(config) {
  return Actor.createActor(asset_idl_default, config);
}

// node_modules/@dfinity/agent/lib/esm/fetch_candid.js
async function fetchCandid(canisterId, agent) {
  if (!agent) {
    agent = await HttpAgent.create();
  }
  const status = await request({
    agent,
    canisterId: Principal.fromText(canisterId),
    paths: ["candid"]
  });
  const candid = status.get("candid");
  if (candid) {
    return candid;
  }
  const tmpHackInterface = ({ IDL }) => IDL.Service({
    __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ["query"])
  });
  const actor = Actor.createActor(tmpHackInterface, { agent, canisterId });
  return await actor.__get_candid_interface_tmp_hack();
}

export {
  defaultStrategy,
  strategy_exports,
  pollForResponse,
  polling_exports,
  ActorCallError,
  QueryCallRejectedError,
  UpdateCallRejectedError,
  Actor,
  ACTOR_METHOD_WITH_HTTP_DETAILS,
  ACTOR_METHOD_WITH_CERTIFICATE,
  getManagementCanister,
  AdvancedActor,
  createAssetCanisterActor,
  fetchCandid
};
//# sourceMappingURL=chunk-QPS7VOWE.js.map
